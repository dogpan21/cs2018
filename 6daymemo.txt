[포인터]

	printf_s("%d %d \n", *ptr, ptr);

 3       / *ptr은 주소에 저장된 값. 
13629856/ ptr은 주소 위치 그 자체.

printf_s("%d %d\n", address, *((int *)address)); //(int*) 포인터형 변수로 타입캐스팅 / *() 그 안의 값을 가져와라.
	//주소 내용보기. 13893160 입력시 -> '5'가 나옴.


배열의 index는 기준을 영어로 잡은 상대적인 주소.
포인터는 메모리에 저장된 절대적인 주소!

int ary[5] = { 10, 20, 30, 40, 50 }; // {}로 감싼다 ()아님!

배열표현    포인터표현
ary[0]      *(ary+0)


//printf_s("%d \n", *(&ary[0]+ i)); //컴파일러가 int를 인식해서 자동으로 4씩 증가한다. *을 빼면 주소들이 나옴.
//printf_s("%d \n", ary[i]);
//printf_s("%d \n", *(ary + i));
printf_s("%d \n", *(ap + i)); //네 줄 모두 다 똑같은 값이다.

[잊지말자!!!!!!! nLength] = sizeof(ary)/sizeof(double)

배열안의 모든 원소는 크기가 동일하므로.(=자료형)


[포인터] = 함수에 값 넘길때나 쓴다!!

int nums[5] = { 1, 2, 3, 4, 5 }; //char nums[5]로 할 경우, &nums의 값이 1바이트 씩 차이난다. 메모리의 최소 단위는 1바이트 이므로!
//배열은 주소를 쭉 나열한 것. nums가 int 인티저형이기 때문에 각 주소 위치가 4씩 차이가 난다.

각 데이터형 별로, 기억공간의 범위 확인하기.
{
	char ch;
	int num;
	double db;

	printf_s("%d %d %d\n", &ch, &num, &db); //11794615 11794600 11794584 책과는 값이 다르다. 주소를 일렬로 못가져오게, 보안책이 심어져있기 때문.


