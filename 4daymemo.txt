[함수]
함수를 만들어쓰면 로직을 가독하기 좋아진다. 반복작업의 효율은 두말 할 것도 없다.

int sum () //헤드옆의 소괄호는 sum이 함수라는 것을 컴파일러에게 알려주는 역할을 한다. 절대 비우면 안됨.
{}         //몸통. 바디


호출스택 (디버깅시 우측 하단에 나옴. call stack. )
호출스택을 따라가면, 특정 함수가 어느 위치에서 사용되어 에러가 발생했는지 추적할 수가 있다. 디버깅의 핵심.
어느 언어를 쓰더라도 중추가 됨. 중요 도구.

void 함수는 리턴값이 없다.

절차적인 생각 키우기.


[배열]

259p 예시 - 5명의 나이. int ages[5]; scanf("%d%d%d%d%d", &ages[0], &ages[1], &ages[2])

루프문 입력은 '엔터'도 입력으로 치므로 힘들다.
(scanf의 한계. 앞에 숫자가 있으면 엔터를 문자입력으로 받아들여버림. 막으려면 버퍼를 추가해야함.

261p 예제해결하기

인스턴싱 초기화. 배열은 항목이 많으므로 초기화가 걸림돌이다. 이를 어떻게 해결할까?




[배열의 원소는 모두 똑같은 사이즈를 지닌다.]

따라서 

(배열의 총 크기/배열 원소 하나의 크기 = 배열 요소의 개수)

가 나온다 (따로 구하는 공식함수는 없음)

 예 : sizeof(ary) / sizeof(ary[0])




 [문자 스트링은 문자열의 끝을 꼭 널문자(\0)로 해주어야만 한다!!!!!!!] 안그러면 중국어 튀어나옴//쓰레기값이 랜덤하게 튀어나옴.

[문자열을 저장하고 출력하기]
char word[50];
scanf("%s", word); //자동으로 널문자[\0, (0x00), 'nul'] 를 채워주는 아주 착한 함수다.
printf("%s", word); //참고로 scanf라고 해도 배열명 앞에 &을 붙이지는 않는다.

[char word[32]; //처음에 길이 명시, 초기화를 안해주면 에러가 난다. 컴퓨터는 그놈의 크기를 알 수 없으므로.]


&& = and
|| = or
! = A가 틀리면 참

fsm


[기호로 보는가 숫자로 보는가]
word[i] = "%c" = 65 or 'A' // 둘 다 맞다!! 



[질문 모으기]

pritnf와 printf_s의 차이는 무엇일까.




널문자 [\0, 0x00, 'nul'] 각각의 정확한 사용법. 10진. 16진, 문자.

if ((word[i] >= 65 && word[i] <= 90) ||  //대문자. 만약 'A'였다면 대소 조건문이 불가능함.
			(word[i] >= 97 && word[i] <= 122)) //소문자. 
		{
		
			word[i] = '*';
		}

        이거 이해 연습하기. 
		
		
		word[i]의 숫자는 아스키코드.

//
[언어적 사고력을 키우는데 집중하기]